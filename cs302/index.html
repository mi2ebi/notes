<!doctype html>
<html>
  <head>
    <title>cs 302</title>
    <link rel="stylesheet" href="https://mi2ebi.github.io/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <h1 class="h0">cs 302</h1>
    <h1>c++ recap</h1>
    <h2>linked lists</h2>
    <p>each node of a (doubly) linked list has</p>
    <ul>
      <li>pointer to the previous element</li>
      <li>the actual data</li>
      <li>pointer to the next element</li>
    </ul>
    <p>
      there's also a pointer <code class="variable">head</code> pointing to the start
      of the list, and likewise for <code class="variable">tail</code> pointing to the
      end
    </p>
<pre>
<span class="keyword">class</span> <span class="type">Node</span> <span class="rainbow0">{</span>
  <span class="keyword">public</span>:
    <span class="type">int</span> <span class="variable">data</span>;
    <span class="type">Node *</span><span class="variable">prev</span>;
    <span class="type">Node *</span><span class="variable">next</span>;
<span class="rainbow0">}</span>;
</pre>
    <p>tail insert / <code><span class="function">push_back</span><span class="rainbow0">(</span><span class="variable">x</span><span class="rainbow0">)</span></code></p>
<pre>
<span class="type">Node *</span><span class="variable">tmp</span>;
<span class="variable">tmp</span> = <span class="keyword">new</span> <span class="type">Node</span>;
<span class="variable">tmp</span>-&gt;<span class="variable">data</span> = <span class="variable">x</span>; <span class="comment">// <span class="rainbow0">(</span><span class="fgmain">*</span><span class="variable">tmp</span><span class="rainbow0">)</span><span class="fgmain">.</span><span class="variable">data</span> <span class="fgmain">=</span> <span class="variable">x</span><span class="fgmain">;</span></span>
<span class="variable">tail</span>-&gt;<span class="variable">next</span> = <span class="variable">tmp</span>;
<span class="variable">tmp</span>-&gt;<span class="variable">prev</span> = <span class="variable">tail</span>;
<span class="variable">tmp</span>-&gt;<span class="variable">next</span> = <span class="constant">nullptr</span>;
<span class="variable">tail</span> = <span class="variable">tmp</span>;
</pre>
    <p>head remove / <code><span class="function">pop_front</span><span class="rainbow0">()</span></code></p>
<pre>
<span class="type">Node *</span><span class="variable">tmp</span>;
<span class="variable">tmp</span> = <span class="variable">head</span>;
<span class="variable">head</span> = <span class="variable">head</span>-&gt;<span class="variable">next</span>;
<span class="keyword">delete</span> <span class="variable">tmp</span>; <span class="comment">// deällocate</span>
<span class="variable">head</span>-&gt;<span class="variable">prev</span> = <span class="constant">nullptr</span>;
</pre>
    <p>swap, assuming pointers <code class="variable">i</code> and <code class="variable">j</code></p>
<pre>
<span class="type">Node *</span><span class="variable">i_left</span>  = <span class="variable">i</span>-&gt;<span class="variable">prev</span>;
<span class="type">Node *</span><span class="variable">i_right</span> = <span class="variable">i</span>-&gt;<span class="variable">next</span>;
<span class="type">Node *</span><span class="variable">j_left</span>  = <span class="variable">j</span>-&gt;<span class="variable">prev</span>;
<span class="type">Node *</span><span class="variable">j_right</span> = <span class="variable">j</span>-&gt;<span class="variable">next</span>;
<span class="variable">i_left</span>-&gt;<span class="variable">next</span>  = <span class="variable">j</span>;
<span class="variable">i_right</span>-&gt;<span class="variable">prev</span> = <span class="variable">j</span>;
<span class="variable">j_left</span>-&gt;<span class="variable">next</span>  = <span class="variable">i</span>;
<span class="variable">j_right</span>-&gt;<span class="variable">prev</span> = <span class="variable">i</span>;
<span class="variable">i</span>-&gt;<span class="variable">prev</span> = <span class="variable">j_left</span>;
<span class="variable">j</span>-&gt;<span class="variable">prev</span> = <span class="variable">i_left</span>;
<span class="variable">i</span>-&gt;<span class="variable">next</span> = <span class="variable">j_right</span>;
<span class="variable">j</span>-&gt;<span class="variable">next</span> = <span class="variable">i_right</span>;
<span class="type">Node *</span><span class="variable">t</span> = <span class="variable">i</span>;
<span class="variable">i</span> = <span class="variable">j</span>;
<span class="variable">j</span> = <span class="variable">t</span>;
</pre>
    <p>we could also just swap the <code class="variable">data</code>s</p>
    <h1>algorithms</h1>
    <dl>
      <dt>algorithm</dt>
      <dd>process to solve a problem, in general, with finite time</dd>
      <dd>
        etymology: <ruby>
          <span lang="ar">الخوارزمي</span><rp>(</rp><rt>alḵawārizmiyy</rt><rp>(</rp>
        </ruby>, the last name of an arabic mathematician
      </dd>
    </dl>
    <p>to measure time we can</p>
    <ul>
      <li>
        call eg <code class="function">time</code> on linux to get the amount of real
        time (not super useful)
      </li>
      <li>
        find growth rate / scaling (count number of steps and classify as proportional
        to some function of input size \(n\))
      </li>
    </ul>
    <h2>asymptotic complexity classes</h2>
    <h3>big O</h3>
    <p>
      \(g(n) = O(f(n))\)<br />
      iff \(g(n) \le cf(n)\) for some \(c &gt; 0\) and \(n \ge n_0 &gt; 0\)
    </p>
    <table>
      <tr> <th>complexity</th>      <th>notation</th>             </tr>
      <tr> <td>constant</td>        <td>\(O(1)\)</td>             </tr>
      <tr> <td>logarithmic</td>     <td>\(O(\log n)\)</td>        </tr>
      <tr> <td>linear</td>          <td>\(O(n)\)</td>             </tr>
      <tr> <td>polylogarithmic</td> <td>\(O(\log^k n)\)</td>      </tr>
      <tr> <td>quadratic</td>       <td>\(O(n^2)\)</td>           </tr>
      <tr> <td>exponential</td>     <td>\(O(a^n), a &gt; 1\)</td> </tr>
    </table>
    <p>examples</p>
    <ul>
      <li>\(n = O(n)\)</li>
      <li>\(3n = O(n)\)</li>
      <li>\(1000n = O(n)\)</li>
      <li>\(1000n + 23 = O(n)\)</li>
      <li>\(\sqrt n = O(n)\) ...this is sort of weak</li>
    </ul>
    <p>big O gives an <i>upper bound</i></p>
    <h3>big &Omega;</h3>
    <p>
      \(g(n) = \Omega(f(n))\)<br />
      iff \(g(n) \ge cf(n)\) for some \(c &gt; 0\) and \(n \ge n_o &gt; 0\)
    </p>
    <p>big omega is a <i>lower bound</i></p>
    <p>examples</p>
    <ul>
      <li>\(n = \Omega(n)\)</li>
      <li>\(3n = \Omega(n)\)</li>
      <li>\(5n^2 = \Omega(n)\) ...this is also weak</li>
    </ul>
    <h3>big &Theta;</h3>
    <p>
      \(g(n) = \Theta(f(n))\)<br />
      iff \(g(n) = O(f(n))\) and \(g(n) = \Omega(f(n))\)
    </p>
    <p>examples</p>
    <ul>
      <li>\(n = \Theta(n)\)</li>
      <li>\(7n = \Theta(n)\)</li>
      <li>\(3n^2 \ne \Theta(n)\) because it's \(\Omega(n)\) but not \(O(n)\)</li>
    </ul>
    <h3>logs</h3>
    <p>
      for time complexity the log base doesn't matter. even though in Real Math
      \(\log x = \log_{10} x\) or \(\ln x\) depending who you ask
    </p>
    <p>\(\log_a n = \Theta(\log n)\) regardless of \(a\)</p>
    <p>\[\log_a n = \frac{\log_b n}{\log_b a}\]</p>
    <h3>calculus</h3>
    <p>\[\lim_{n \to \infty} \frac{g(n)}{f(n)}\]</p>
    <p>this could</p>
    <ul>
      <li>
        go to infinity, in which case \(f\) can't keep up with \(g\) at all<br />
        <span style="color: var(--green-intense)">\(g(n) = \Omega(f(n))\)</span>
      </li>
      <li>
        be a constant bigger than 0, in which case \(g\) and \(f\) have the
        same growth rate<br />
        <span style="color: var(--green-intense)">\(g(n) = \Theta(f(n))\)</span>
      </li>
      <li>
        be zero, in which case \(f\) is strong enough to pull \(g\) down to zero<br />
        <span style="color: var(--green-intense)">\(g(n) = O(f(n))\)</span>
      </li>
    </ul>
    <p>l'h&ocirc;pital's rule says</p>
    <p>\[
      \lim_{n \to \infty} \frac{g(x)}{f(x)}
      = \lim_{n \to \infty} \frac{g'(n)}{f'(n)} = \cdots
    \]</p>
    <style>.yes{color:var(--green-intense)}.no{color:var(--red-intense)}</style>
    <p>eg does \(n^2 + 33n + 2 = O(n)\)?</p>
    <p>using normal math: \[
      \lim_{n \to \infty} \frac{n^2 + 33n + 2}n
      = \lim_{n \to \infty} \left(n + 33 + \frac2n\right) = \infty
    \]</p>
    <p>using l'hopital's: \[
      \lim_{n \to \infty} \frac{n^2 + 33n + 2}n
      = \lim_{n \to \infty} (2n + 33) = \infty
    \]</p>
    <p>
      therefore \(n\) is <span class="no">not</span> an upper bound for
      \(n^2 + 33n + 2\)
    </p>
    <p>does \(\sqrt n = O(\log n)\)?</p>
    <p>\[
      \lim_{n \to \infty} \frac{\sqrt n}{\ln n}
      = \lim_{n \to \infty} \frac n{2 \sqrt n}
      = \lim_{n \to \infty} \frac{\sqrt n}2
      = \infty
    \]</p>
    <p><span class="no">no</span></p>
    <p>logs are very nice for runtime</p>
    <h1>searching</h1>
    <h2>linear search</h2>
<pre>
<span class="comment">// a : array
// n : size
// s : searchee</span>
<span class="type">bool</span> <span class="function">find</span>(<span class="type">int</span> <span class="variable">a</span><span class="rainbow1">[]</span>, <span class="type">int</span> <span class="variable">n</span>, <span class="type">int</span> <span class="variable">s</span>) {
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> <span class="variable">i</span> = <span class="constant">0</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span>++<span class="rainbow1">)</span> <span class="comment">// O(n)</span>
    <span class="keyword">if</span> <span class="rainbow2">(</span><span class="variable">a</span><span class="rainbow3">[</span><span class="variable">i</span><span class="rainbow3">]</span> == <span class="variable">s</span><span class="rainbow2">)</span> <span class="comment">// O(1)</span>    <span class="comment">//</span>
      <span class="keyword">return</span> <span class="constant">true</span>; <span class="comment">//</span>         <span class="comment">//</span>
  <span class="keyword">return</span> <span class="constant">false</span>;
}
</pre>
    <p>worst case, <code class="variable">s</code> isn't in the array at all.</p>
    <p>\(O(n)\), \(\Omega(n)\), \(\Theta(n)\)</p>
    <p>best case, <code><span class="variable">s</span> == <span class="variable">a</span>[<span class="constant">0</span>]</code></p>
    <p>\(O(1)\), \(\Omega(1)\), \(\Theta(1)\)</p>
    <p>average case, <code class="variable">s</code> is in the middle</p>
    <p>\(O(n)\), \(\Omega(n)\), \(\Theta(n)\)</p>
    <h2>binary search</h2>
<pre>
<span class="type">bool</span> <span class="function">find</span>(<span class="type">int</span> <span class="variable">a</span><span class="rainbow1">[]</span>, <span class="type">int</span> <span class="variable">n</span>, <span class="type">int</span> <span class="variable">s</span>) {
  <span class="type">int</span> <span class="variable">l</span> = <span class="constant">0</span>;
  <span class="type">int</span> <span class="variable">r</span> = <span class="variable">n</span> - <span class="constant">1</span>;
  <span class="type">int</span> <span class="variable">m</span>;
  <span class="keyword">while</span> <span class="rainbow1">(</span><span class="variable">l</span> &lt;= <span class="variable">r</span><span class="rainbow1">)</span> <span class="rainbow1">{</span>
    <span class="variable">m</span> = <span class="variable">l</span> + <span class="rainbow2">(</span><span class="variable">r</span> - <span class="variable">l</span><span class="rainbow2">)</span> / <span class="constant">2</span>; <span class="comment">// O(1)</span>
    <span class="keyword">if</span> <span class="rainbow2">(</span><span class="variable">a</span><span class="rainbow3">[</span><span class="variable">m</span><span class="rainbow3">]</span> == <span class="variable">s</span><span class="rainbow2">)</span>       <span class="comment">//</span>
      <span class="keyword">return</span> <span class="constant">true</span>;       <span class="comment">//</span>
    <span class="keyword">if</span> <span class="rainbow2">(</span><span class="variable">a</span><span class="rainbow3">[</span><span class="variable">m</span><span class="rainbow3">]</span> &lt; <span class="variable">s</span><span class="rainbow2">)</span>        <span class="comment">//</span>
      <span class="variable">l</span> = <span class="variable">m</span> + <span class="constant">1</span>;         <span class="comment">//</span>
    <span class="keyword">else</span>                 <span class="comment">//</span>
      <span class="variable">r</span> = <span class="variable">m</span> - <span class="constant">1</span>;         <span class="comment">//</span>
  <span class="rainbow1">}</span>
  <span class="keyword">return</span> <span class="constant">false</span>;
}
</pre>
    <p>worst case, <code class="variable">s</code> isn't in the array at all</p>
    <p>\(O(\log n)\), \(\Omega(\log n)\), \(\Theta(\log n)\)</p>
    <h1>some loops</h1>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="constant">0</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span> += <span class="constant">3</span>)
  <span class="variable">cout</span> &lt;&lt; "...";
</pre>
    <p>\(
      \frac13 \sum\limits_{i = 0}^{n - 1} 1 = \frac n3 = \Theta(n)
    \)</p>
    <p>the counter updater bit is a big clue as to the complexity</p>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="variable">n</span>; <span class="variable">i</span> &gt; <span class="constant">0</span>; <span class="variable">i</span> /= <span class="constant">2</span>)
  <span class="variable">cout</span> &lt;&lt; ...;
</pre>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="constant">1</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span> *= <span class="constant">2</span>)
  <span class="variable">cout</span> &lt;&lt; ...;
</pre>
    <p>these are both \(\log_2 n = \Theta(\log n)\)</p>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="constant">0</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span>++)
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> <span class="variable">j</span> = <span class="constant">0</span>; <span class="variable">j</span> &lt; <span class="variable">n</span>; <span class="variable">j</span>++<span class="rainbow1">)</span>
    <span class="variable">cout</span> &lt;&lt; ...;
</pre>
    <p>\(
      \sum\limits_{i = 0}^{n - 1} \sum\limits_{j = 0}^{n - 1} 1
      = \sum\limits_{i = 0}^{n - 1} n
      = n^2 = \Theta(n^2)
    \)</p>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="constant">0</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span>++)
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> <span class="variable">j</span> = <span class="constant">0</span>; <span class="variable">j</span> &lt; <span class="variable">i</span>; <span class="variable">j</span>++<span class="rainbow1">)</span>
    <span class="variable">cout</span> &lt;&lt; ...;
</pre>
    <p>\(
      \sum\limits_{i = 0}^{n - 1} \sum\limits_{j = 0}^{i - 1} 1
      = \sum\limits_{i = 0}^{n - 1} i
      = \frac n2 (n - 1) 
      = \frac{n^2}2 - \frac n2
      = \Theta(n^2)
    \)</p>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="constant">0</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span>++)
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> <span class="variable">j</span> = <span class="constant">1</span>; <span class="variable">j</span> &lt; <span class="variable">n</span>; <span class="variable">j</span> *= <span class="constant">2</span><span class="rainbow1">)</span>
    <span class="variable">cout</span> &lt;&lt; ...;
</pre>

    <p>\(\Theta(n\log n)\)</p>
<pre>
<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> = <span class="constant">0</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span>++)
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> <span class="variable">j</span> = <span class="constant">1</span>; <span class="variable">j</span> &lt; <span class="variable">i</span>; <span class="variable">j</span> *= <span class="constant">2</span><span class="rainbow1">)</span>
    <span class="variable">cout</span> &lt;&lt; ...;
</pre>
    <p>since \(\log 0\) is undefined we can cheat and do \(
      \sum\limits_{i = 1}^n \log_2 i
      = \log_2(n!)
    \)</p>
    <p>but \(\log_2(n!)\) isn't v useful</p>
    <p>the log base doesn't matter so \[
      \sum_{i = 1}^n \ln n
      \approx \int_1^n \ln x \;\mathrm d x
      = \left.(x \ln n - x)\vphantom\int\right|_1^n
      = n \ln n - n + 1
      = \Theta(n \log n)
    \]</p>
    <h1>sorting</h1>
    <h2>insertion sort</h2>
<pre>
<span class="type">void</span> <span class="function">insertionSort</span>(<span class="type">int</span> <span class="variable">a</span><span class="rainbow1">[]</span>, <span class="type">int</span> <span class="variable">n</span>) {
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> <span class="variable">i</span> = <span class="constant">1</span>; <span class="variable">i</span> &lt; <span class="variable">n</span>; <span class="variable">i</span>++<span class="rainbow1">)</span> <span class="rainbow1">{</span>
    <span class="type">int</span> <span class="variable">key</span> = <span class="variable">a</span><span class="rainbow2">[</span><span class="variable">i</span><span class="rainbow2">]</span>;
    <span class="type">int</span> <span class="variable">j</span> = <span class="variable">i</span> - <span class="constant">1</span>;
    <span class="keyword">while</span> <span class="rainbow2">(</span><span class="variable">j</span> &gt;= <span class="constant">0</span> && <span class="variable">a</span><span class="rainbow3">[</span><span class="variable">j</span><span class="rainbow3">]</span> &gt; <span class="variable">key</span><span class="rainbow2">)</span> <span class="rainbow2">{</span>
      <span class="variable">a</span><span class="rainbow3">[</span><span class="variable">j</span> + <span class="constant">1</span><span class="rainbow3">]</span> = <span class="variable">a</span><span class="rainbow3">[</span><span class="variable">j</span><span class="rainbow3">]</span>;
      <span class="variable">j</span>--;
    <span class="rainbow2">}</span>
    <span class="variable">a</span><span class="rainbow2">[</span><span class="variable">j</span> + <span class="constant">1</span><span class="rainbow2">]</span> = <span class="variable">key</span>;
  <span class="rainbow1">}</span>
}
</pre>
    <p>
      after every iteration of the outer loop, the slice of the array from
      <code class="constant">0</code>
      to
      <code><span class="variable">i</span> - <span class="constant">1</span></code>
      is always sorted
    </p>
    <p>the inner loop makes room for the key to be inserted</p>
    <p>
      worst case, the list of reversed and <code class="variable">j</code> has to go
      all the way to <code class="constant">-1</code> every time
    </p>
    <p>
      this is a nice \(\frac n2 (n - 2)\) situation, so it's \(\Theta(n^2)\). not great
    </p>
    <p>best case, it's already sorted and the inner loop never runs</p>
    <p>then it's just \(\Theta(n)\)</p>
    <h2>merge sort</h2>
    <p>'divide and conquer' algorithm, which unfortunately necessitates recursion</p>
    <ul>
      <li>split the array into 2 pieces (the left side and the right side)</li>
      <li>
        recursively <code class="function">mergeSort</code> each half to get two
        sorted half arrays
      </li>
      <li>merge the halves</li>
    </ul>
<pre>
<span class="type">void</span> <span class="function">mergeSort</span>(<span class="type">int</span> a<span class="rainbow1">[]</span>, <span class="type">int</span> l, <span class="type">int</span> r) {
  <span class="keyword">if</span> <span class="rainbow1">(</span>l &gt;= r<span class="rainbow1">)</span>
    <span class="keyword">return</span>;
  <span class="type">int</span> m = l + <span class="rainbow1">(</span>r - l<span class="rainbow1">)</span> / <span class="constant">2</span>;
  <span class="function">mergeSort</span><span class="rainbow1">(</span>a, l, m<span class="rainbow1">)</span>;
  <span class="function">mergeSort</span><span class="rainbow1">(</span>a, m + <span class="constant">1</span>, r<span class="rainbow1">)</span>;
  <span class="function">merge</span><span class="rainbow1">(</span>a, l, m, r<span class="rainbow1">)</span>;
}
<span class="type">void</span> <span class="function">merge</span>(<span class="type">int</span> a<span class="rainbow1">[]</span>, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r) {
  <span class="type">int</span> i = l, j = m + <span class="constant">1</span>, k = <span class="constant">0</span>;
  <span class="type">int</span> b<span class="rainbow1">[</span>r - l + 1<span class="rainbow1">]</span>;
  <span class="keyword">while</span> <span class="rainbow1">(</span>i &lt;= m &amp;&amp; j &lt;= r<span class="rainbow1">)</span>
    <span class="keyword">if</span> (a[i] &lt;= a[j])
      b[k++] = a[i++];
    <span class="keyword">else</span>
      b[k++] = a[j++];
  <span class="keyword">while</span> <span class="rainbow1">(</span>i &lt;= m<span class="rainbow1">)</span>
    b[k++] = a[i++];
  <span class="keyword">while</span> <span class="rainbow1">(</span>j &lt;= r<span class="rainbow1">)</span>
    b[k++] = a[j++];
  <span class="keyword">for</span> <span class="rainbow1">(</span><span class="type">int</span> x = 0; x &lt; k; x++<span class="rainbow1">)</span>
    a[l + x] = b[x];
}
</pre>
    <p>
      merging all the arrays at a given level together is \(\Theta(n)\), and there are
      around \(\log_2 n\) levels
    </p>
    <p>which means it's better than insertion sort!</p>
    <h2>quicksort</h2>
    <p>another recursive one</p>
    <ul>
      <li>choose a pivot (any element of the array)</li>
      <li>
        partition the list into the elements less than the pivot and the elements
        greater than the pivot
      </li>
      <li>call <code class="function">quickSort</code> on each side</li>
    </ul>
<pre>
int partition(int a[], int l, int r) {
  int pivot = a[l]; // easy
  int i = l + 1, j = r;
  while (i &lt;= j) {
    if (a[i] &lt;= pivot) i++;
    if (a[j] &gt; pivot) j--;
    // if i and j both didn't move
      // swap a[i++] and a[j--]
  }
  return j;
}
</pre>
    <p>worst case, the list is already sorted: \(O(n^2)\)</p>
    <p>best case the pivot is the median: \(O(n\log n)\)</p>
    <p>methods to avoid worst case:</p>
    <ul>
      <li>trust me bro :) dont worry about it :) itll be fiiiine :)</li>
      <li>randomly choose a pivot instead of always using the first element</li>
      <li>find the median of an unsorted array without sorting it...?</li>
    </ul>
    <h1>binary trees</h1>
    <p>honestly not very useful in and of themselves</p>
    <p>we have a <code class="variable">root</code> pointer that points to a node, sort of analagous to the head of a linked list</p>
<pre>
     a
  b--'--c
d-'-e f-'-g
</pre>
<pre>
class BinTreeNode {
  public:
    int data;
    BinTreeNode* left;
    BinTreeNode* right;
}
</pre>
    <h2>traversing</h2>
    <p>more recursion! base case is the tree being empty. recursive case is a node where left and right point to a smaller binary tree</p>
    <p>there are a couple different ways to traverse a tree</p>
    <pre>
void preorder(BinTreeNode* r) {
  if (r == nullptr)
    return;
  cout &lt;&lt; r->data; // preorder process
  preorder(r->left);
  preorder(r->right);
}
void postorder(BinTreeNode* r) {
  if (r == nullptr)
    return;
  postorder(r->left);
  postorder(r->right);
  cout &lt;&lt; r->data;
}</pre>
    <script src="../temml.min.js"></script>
    <script>temml.renderMathInElement(document.body, {trust:true});</script>
  </body>
</html>
