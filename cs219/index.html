<!doctype html>
<html>
  <head>
    <title>cs 219</title>
    <link rel="stylesheet" href="https://mi2ebi.github.io/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <h1 class="h0">cs 219</h1>
    <p><b>TODO</b> renumber to use chapters</p>
    <h1>2026-01-20</h1>
    <p>computers and brains are very similar!</p>
<pre>
        <span style="color: var(--green)">program</span>
           v
<span style="color: var(--red)">input</span> &gt; <span style="color: var(--green)">process</span> &gt; <span style="color: var(--magenta-cooler)">output</span>
           v
        <span style="color: var(--green)">storage</span>
</pre>
    <h2>parts of computers</h2>
    <ul>
      <li>input eg keyboard/mouse</li>
      <li>output eg screen</li>
      <li>memory</li>
      <li>
        processor
        <ul>
          <li>data path</li>
          <li>control unit</li>
        </ul>
      </li>
    </ul>
    <p>von neumann is slow tho so we can separate instruction memory vs data memory</p>
    <h2>types of computers</h2>
    <dl>
      <dt>personal computers</dt>
      <dd>general purpose, cost/perf tradeoff</dd>
      <dt>servers</dt>
      <dd>high capacity, performance, reliability</dd>
      <dt>supercomputers</dt>
      <dd>type of server, highest capabaility but super expensive etc</dd>
      <dt>embedded computers</dt>
      <dd>
        hidden as components of other systems, strict power/cost/perf requirements
      </dd>
      <dt>mobile devices</dt>
      <dd>rely more on batteries rather than eg being plugged in all the time</dd>
    </dl>
    <h2>"eight great ideas"</h2>
    <ol>
      <li>design for moore's law</li>
      <li>use abstraction to simplify design</li>
      <li>make the common case fast</li>
      <li>performance via parallelism</li>
      <li>performance via pipelining</li>
      <li>performance via prediction</li>
      <li>hierarchy of memories</li>
      <li>dependability via redundancy</li>
    </ol>
    <h1>2026-01-22</h1>
    <h2>below your program</h2>
    <ol>
      <li>application software</li>
      <li>system software eg compiler, os</li>
      <li><b>instruction set architecture</b></li>
      <li>hardware eg processor, memory, i/o</li>
    </ol>
    <h2>inside the cpu</h2>
    <dl>
      <dt>datapath</dt>
      <dd>perform ops on data</dd>
      <dt>control</dt>
      <dd>sequences datapath, memory, i/o</dd>
      <dt>cache</dt>
      <dd>small fast sram</dd>
    </dl>
    <dl>
      <dt>volatile/primary/main memory</dt>
      <dd>loses state when powered off</dd>
      <dt>nonvolatile/secondary memory</dt>
      <dd>eg hard drive, ssd, cdrom, usb stick</dd>
    </dl>
    <h2>networks</h2>
    <dl>
      <dt>local area network (lan)</dt>
      <dd>ethernet</dd>
      <dt>wide area network (wan)</dt>
      <dd>the internet</dd>
      <dt>wireless network</dt>
      <dd>eg wifi, bluetooth</dd>
    </dl>
    <h2>performance</h2>
    <dl>
      <dt>response time</dt>
      <dd>how long it takes to do something</dd>
      <dt>throughput</dt>
      <dd>total work done per unit of time</dd>
    </dl>
    <p>to get 'better performance':</p>
    <ul>
      <li>replace processor (rt down, t up)</li>
      <li>add more proessors (no changes to rt or t)</li>
    </ul>
    <p>perf &prop; 1/exectime</p>
    <h1>2026-01-27</h1>
    <p>
      a "2&#x202f;GHz" processor has a 1/(2&#x202f;GHz) = 0.5&#x202f;ns <small>=
      500&#x202f;ps</small> <b>clock cycle</b>
    </p>
    <p>ExecTime = ClockCycles &times; CycleTime = ClockCycles / ClockRate</p>
    <blockquote>
      [the math] is trying to touch your brain a little bit.
      squeeze it, but not crush it<br />
      &ndash; <cite>prof chidella</cite>
    </blockquote>
    <p>CPI = clock cycles per instruction</p>
    <p>in mips, memory instructions take the most clock cycles</p>
    <p>
      mips stands for <del>million instructions per second</del> <ins>microprocessor without interlocked pipeline stages</ins>
    </p>
    <dl>
      <dt>standard equation for ET</dt>
      <dd>
        ET<br />
        = CC &times; CT<br />
        = IC &times; CPI &times; CT<br />
        = IC &times; CPI / CR
      </dd>
    </dl>
    <h1>2026-01-29</h1>
    <h2>bin and hex</h2>
    <p>to convert positive integers to binary: keep dividing by 2 until you get a result less than 2, and prepend each remainder + that final result</p>
<pre>
<span class="keyword">fn</span> <span class="function">udec2bin</span>(<span class="variable">x</span>: <span class="type">u32</span>) -&gt; <span class="type">String</span> {
  <span class="keyword">if</span> <span class="variable">x</span> == <span class="constant">0</span> <span class="rainbow1">{</span>
    <span class="keyword">return</span> <span class="string">"0"</span>.<span class="function">to_string</span><span class="rainbow2">()</span>;
  <span class="rainbow1">}</span>
  <span class="keyword">let mut</span> <span class="variable">bin</span> = <span class="type">String</span>::<span class="function">new</span><span class="rainbow1">()</span>;
  <span class="keyword">let mut</span> <span class="variable">x</span> = <span class="variable">x</span>;
  <span class="keyword">while</span> <span class="variable">x</span> &gt; <span class="constant">0</span> <span class="rainbow1">{</span>
    <span class="variable">bin</span> = <span class="builtin">format!</span><span class="rainbow2">(</span><span class="string">"<span class="rainbow3">{}{</span><span class="variable">bin</span><span class="rainbow3">}</span>"</span>, <span class="variable">x</span> % <span class="constant">2</span><span class="rainbow2">)</span>;
    <span class="variable">x</span> /= <span class="constant">2</span>;
  <span class="rainbow1">}</span>
  <span class="variable">bin</span>
}
</pre>
    <p>for negative integers use 2s complement</p>
    <ol>
      <li>ignore the sign and convert it as if it were positive</li>
      <li>1s complement (flip all the bits)</li>
      <li>add 1</li>
    </ol>
    <p>
      the range of a signed <i>n</i>-bit integer type is -2<sup><i>n</i>&minus;1</sup>
      to 2<sup><i>n</i>&minus;1</sup>&nbsp;&minus;&nbsp;1
    </p>
    <p>
      eg <code class="type">int</code> can store numbers from -2,147,483,648 to 2,147,483,647
    </p>
    <h2>"4 design principles"</h2>
    <ol>
      <li>simplicity favors regularity</li>
    </ol>
    <p>
      risc has 1 implementation for eg <code class="function">add</code> where cisc can
      add <a href="https://www.felixcloutier.com/x86/add">tons of types of thing</a>
      with the same instruction. in risc there's just
    </p>
<pre>
<span class="comment"># rd = rs + rt</span>
<span class="function">add</span> <span class="variable">rd</span>, <span class="variable">rs</span>, <span class="variable">rt</span>
</pre>
    <ol start="2">
      <li>smaller is faster</li>
    </ol>
    <p>risc uses only 32bit registers, cisc uses whatever the native size is</p>
    <p>and risc has less <i>number of</i> registers</p>
    <h1>2026-02-03</h1>
    <ol start="3">
      <li>make the common case fast</li>
    </ol>
    <p>storing stuff in registers is faster than going to main memory every time</p>
<pre>
<span class="function">move</span> <span class="constant">$t0</span>, <span class="constant">$t1</span>
<span class="comment"># is secretly</span>
<span class="function">add</span> <span class="constant">$t0</span>, <span class="constant">$0</span>, <span class="constant">$t1</span>
</pre>
    <aside>
      <p>see also <a href="../cs218">cs218</a> for mips</p>
    </aside>
    <ol start="4">
      <li>good design demands good compromise</li>
    </ol>
    <p>i) every instruction is 32 bits<br/>ii) minimal changes btwn instr formats</p>
    <h2>r-format instructions</h2>
    <p>used by the ALU</p>
<pre>
6      5     5     5     5     6
000000 00000 00000 00000 00000 000000
opcode rs    rt    rd    shamt funct
</pre>
    <p>risc has 32 registers so the registers each take up 5 bits</p>
    <p><coee>shamt</coee> is 'shift amount', used only for shl/shr, also 5 bits</p>
    <h2>i-format instructions</h2>
<pre>
6      5     5     16
000000 00000 00000 0000000000000000
opcode rs    rt    imm
</pre>
    <p><code>rt</code> is sometimes a source and sometimes a destination</p>
    <p>eg</p>
<pre>
<span class="function">lw</span> <span class="constant">$s0</span>, <span class="constant">4</span>(<span class="constant">$s2</span>)
</pre>
    <ul>
      <li><code class="constant">$s2</code> is <code>rs</code>
      <li><code class="constant">$s0</code> is <code>rt</code>
      <li><code class="constant">4</code> is the <i>offset</i> and goes in <code>imm</code>
    </ul>
    <h2>j-format instructions</h2>
<pre>
6      26
000000 00000000000000000000000000
opcode imm/addr
</pre>
    <h1>2026-02-09</h1>
    <h2>mips to hex</h2>
    <h3><code>
      <span class="function">add</span>
      <span class="constant">$t2</span><span class="fgmain">,</span>
      <span class="constant">$t0</span><span class="fgmain">,</span>
      <span class="constant">$t1</span>
    </code></h3>
    <p>
      the opcode is always 0 for r-format instructions. instead every r-format
      instruction has a function number. <code class="function">add</code>'s is 32
    </p>
    <p><code class="constant">$t0</code> has a register number of 8 etc</p>
    <p>so our instruction in binary is</p>
<pre>
000000 01000 01001 01010 00000 100000
0      8     9     10    0     32
</pre>
    <p>and in hex this is</p>
<pre>
0000 0001 0000 1001 0101 0000 0010 0000
0    1    0    9    5    0    2    0
</pre>
    <p> = <code>0x01095020</code></p>
    <h3><code>
      <span class="function">sw</span>
      <span class="constant">$s7</span><span class="fgmain">,</span>
      <span class="constant">4</span><span class="fgmain">(</span><span class="constant">$t0</span><span class="fgmain">)</span>
    </code></h3>
    <p><code class="function">sw</code>'s opcode is 43
<pre>
101011 01000 10111 0000000000000100
43     8     23    4
</pre>
<pre>
1010 1101 0001 0111 0000 0000 0000 0100
a    c    1    7    0    0    0    4
</pre>
    <p>= <code>0xac170004</code></p>
    <h3><code>
      <span class="function">j</span> <span class="constant">0x10000</span>
    </code></h3>
    <p>how do you fit a 32 bit address into 26 bits? you don't!</p>
    <p>
      offset address = (label address &minus; <code class="constant">$pc</code>) / 4
    </p>
    <p>
      tells you the number of instructions away it is! since instructions are
      <code class="type">int</code>s and therefore are 4 bytes long
    </p>
    <h1>2026-02-10</h1>
    <h2>logical instructions</h2>
    <p>useful for extracting and inserting certain groups of bits</p>
    <h3 class="smcp">and</h3>
    <p><code>and rd, rs, rt</code></p>
    <table>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>A &and; B</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
    </table>
    <h3 class="smcp">or</h3>
    <p><code>or rd, rs, rt</code></p>
    <table>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>A &or; B</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
    </table>
    <h3 class="smcp">nor</h3>
    <p><code>nor rd, rs, rt</code></p>
    <p>= 1s complement of <span class="smcp">or</span></p>
    <table>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>A &darr; B</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
      </tr>
    </table>
    <h3 class="smcp">not</h3>
    <p><code>nor rd, rs, $0</code></p>
    <p>for integers &not;<i>x</i> = -<i>x</i> &minus; 1</p>
    <table>
      <tr>
        <th>A</th>
        <th>&not;A</th>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
      </tr>
    </table>
    <h3>logical left shift</h3>
    <p><code>sll rd, rt, shamt</code></p>
    <p>eg <code>0b00001001</code> &ll; 2 = <code>0b00100100</code></p>
    <p>
      for unsigned integers this produces <i>rs</i> &times; 2<sup><i>shamt</i></sup>
    </p>
    <h3>logical right shift</h3>
    <p><code>srl rd, rt, shamt</code></p>
    <p>eg <code>0b10010001</code> &gg; 2 = <code>0b00100100</code></p>
    <p>for unsigned integers this produces <i>rs</i> / 2<sup><i>shamt</i></sup></p>
    <h2>32-bit constants</h2>
    <p>
      most constants are small. i-format instructions can only handle 16-bit immediates
    </p>
    <p>to put <code>0x12345678</code> into <code>$t0</code>, you write</p>
<pre>
<span class="function">li</span> $t0, 0x12345678
<span class="comment"># is assembled into</span>
<span class="function">lui</span> $at, 0x1234       <span class="comment"># Load Upper Immediate</span>
<span class="function">ori</span> $t0, $at, 0x5678
</pre>
    <h1>2026-02-12</h1>
    <h2>addition</h2>
    <p><b>signed</b> numbers can be positive and negative and <b>unsigned</b> numbers can only be positive</p>
    <dl>
      <dt>overflow</dt>
      <dd>value outside the range that can fit, eg trying to fit 3&times;10<sup>9</sup> into an <code class="type">int</code></dd>
      <dt>underflow</dt>
      <dd>value less than the range, only for floating point numbers</dd>
    </dl>
    <p>if you try adding 2 negative numbers and get an extra bit, it doesn't count as an overflow unless the sign bit changes to positive. -3 + -3 = -6 doesn't overflow, but -6 + -8 = -14 = 2 does</p>
    <p>adding a positive and negative number will never overflow</p>
    <h2>multiplication</h2>
    <p>multipying two <i>n</i>-digit number gives an up-to-(2<i>n</i>)-digit number! whatever will we do!</p>
    <p>mips has 2 bonus registers <code>hi</code> and <code>lo</code> which together store a 64-bit number</p>
    <p>multiplying individual bits is like an <span class="smcp">and</span> gate</p>
    <h1>2026-02-17</h1>
    <h2>algorithm 1</h2>
    <h2>optimized algorithm</h2>
    <p>here the multiplicand and multiplier are both eg 4 bits and the product is twice that</p>
    <ol>
      <li>place the multiplier in the right half of the product</li>
      <li>for each bit of the multiplier,
        <ol>
          <li>if the lsb is 1, add the multiplicand to the left half of the product</li>
          <li>shift the entire product right 1 bit</li>
        </ol>
      </li>
    </ol>
    <p>for 2 &times; 3 = 6:</p>
    <table>
      <tr><th>iter</th><th>product</th></tr>
      <tr><td>0</td><td>0000'0011</td></tr>
      <tr><td rowspan="2">1</td><td>0010'0011</td></tr>
      <tr><td>0001'0001</td></tr>
      <tr><td rowspan="2">2</td><td>0011'0001</td></tr>
      <tr><td>0001'1000</td></tr>
      <tr><td>3</td><td>0000'1100</td></tr>
      <tr><td>4</td><td>0000'0110</td></tr>
    </table>
    <h2>booth's algorithm with sign extension</h2>
  </body>
</html>
