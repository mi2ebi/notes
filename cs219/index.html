<!doctype html>
<html>
  <head>
    <title>cs 219</title>
    <link rel="stylesheet" href="https://mi2ebi.github.io/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <h1 class="h0">cs 219</h1>
    <p><b>TODO</b> renumber to use chapters</p>
    <h1>2026-01-20</h1>
    <p>computers and brains are very similar!</p>
<pre>
        <span style="color: var(--green)">program</span>
           v
<span style="color: var(--red)">input</span> &gt; <span style="color: var(--green)">process</span> &gt; <span style="color: var(--magenta-cooler)">output</span>
           v
        <span style="color: var(--green)">storage</span>
</pre>
    <h2>parts of computers</h2>
    <ul>
      <li>input eg keyboard/mouse</li>
      <li>output eg screen</li>
      <li>memory</li>
      <li>
        processor
        <ul>
          <li>data path</li>
          <li>control unit</li>
        </ul>
      </li>
    </ul>
    <p>von neumann is slow tho so we can separate instruction memory vs data memory</p>
    <h2>types of computers</h2>
    <dl>
      <dt>personal computers</dt>
      <dd>general purpose, cost/perf tradeoff</dd>
      <dt>servers</dt>
      <dd>high capacity, performance, reliability</dd>
      <dt>supercomputers</dt>
      <dd>type of server, highest capabaility but super expensive etc</dd>
      <dt>embedded computers</dt>
      <dd>
        hidden as components of other systems, strict power/cost/perf requirements
      </dd>
      <dt>mobile devices</dt>
      <dd>rely more on batteries rather than eg being plugged in all the time</dd>
    </dl>
    <h2>"eight great ideas"</h2>
    <ol>
      <li>design for moore's law</li>
      <li>use abstraction to simplify design</li>
      <li>make the common case fast</li>
      <li>performance via parallelism</li>
      <li>performance via pipelining</li>
      <li>performance via prediction</li>
      <li>hierarchy of memories</li>
      <li>dependability via redundancy</li>
    </ol>
    <h1>2026-01-22</h1>
    <h2>below your program</h2>
    <ol>
      <li>application software</li>
      <li>system software eg compiler, os</li>
      <li><b>instruction set architecture</b></li>
      <li>hardware eg processor, memory, i/o</li>
    </ol>
    <h2>inside the cpu</h2>
    <dl>
      <dt>datapath</dt>
      <dd>perform ops on data</dd>
      <dt>control</dt>
      <dd>sequences datapath, memory, i/o</dd>
      <dt>cache</dt>
      <dd>small fast sram</dd>
    </dl>
    <dl>
      <dt>volatile/primary/main memory</dt>
      <dd>loses state when powered off</dd>
      <dt>nonvolatile/secondary memory</dt>
      <dd>eg hard drive, ssd, cdrom, usb stick</dd>
    </dl>
    <h2>networks</h2>
    <dl>
      <dt>local area network (lan)</dt>
      <dd>ethernet</dd>
      <dt>wide area network (wan)</dt>
      <dd>the internet</dd>
      <dt>wireless network</dt>
      <dd>eg wifi, bluetooth</dd>
    </dl>
    <h2>performance</h2>
    <dl>
      <dt>response time</dt>
      <dd>how long it takes to do something</dd>
      <dt>throughput</dt>
      <dd>total work done per unit of time</dd>
    </dl>
    <p>to get 'better performance':</p>
    <ul>
      <li>replace processor (rt down, t up)</li>
      <li>add more proessors (no changes to rt or t)</li>
    </ul>
    <p>perf &prop; 1/exectime</p>
    <h1>2026-01-27</h1>
    <p>
      a "2&#x202f;GHz" processor has a 1/(2&#x202f;GHz) = 0.5&#x202f;ns <small>=
      500&#x202f;ps</small> <b>clock cycle</b>
    </p>
    <p>ExecTime = ClockCycles &times; CycleTime = ClockCycles / ClockRate</p>
    <blockquote>
      [the math] is trying to touch your brain a little bit.
      squeeze it, but not crush it<br />
      &ndash; <cite>prof chidella</cite>
    </blockquote>
    <p>CPI = clock cycles per instruction</p>
    <p>in mips, memory instructions take the most clock cycles</p>
    <p>
      mips stands for <del>million instructions per second</del> <ins>microprocessor without interlocked pipeline stages</ins>
    </p>
    <dl>
      <dt>standard equation for ET</dt>
      <dd>
        ET<br />
        = CC &times; CT<br />
        = IC &times; CPI &times; CT<br />
        = IC &times; CPI / CR
      </dd>
    </dl>
    <h1>2026-01-29</h1>
    <h2>bin and hex</h2>
    <p>to convert positive integers to binary: keep dividing by 2 until you get a result less than 2, and prepend each remainder + that final result</p>
    <p>for negative integers use 2s complement</p>
    <ol>
      <li>ignore the sign and convert it as if it were positive</li>
      <li>1s complement (flip all the bits)</li>
      <li>add 1</li>
    </ol>
    <p>
      the range of a signed <i>n</i>-bit integer type is -2<sup><i>n</i>&minus;1</sup>
      to 2<sup><i>n</i>&minus;1</sup>&nbsp;&minus;&nbsp;1
    </p>
    <p>
      eg <code class="type">int</code> can store numbers from -2,147,483,648 to 2,147,483,647
    </p>
    <h2>"4 design principles"</h2>
    <ol>
      <li>simplicity favors regularity</li>
    </ol>
    <p>
      risc has 1 implementation for eg <code class="function">add</code> where cisc can
      add <a href="https://www.felixcloutier.com/x86/add">tons of types of thing</a>
      with the same instruction. in risc there's just
    </p>
<pre>
<span class="comment"># rd = rs + rt</span>
<span class="function">add</span> <span class="variable">rd</span>, <span class="variable">rs</span>, <span class="variable">rt</span>
</pre>
    <ol start="2">
      <li>smaller is faster</li>
    </ol>
    <p>risc uses only 32bit registers, cisc uses whatever the native size is</p>
    <p>and risc has less <i>number of</i> registers</p>
    <h1>2026-02-03</h1>
    <ol start="3">
      <li>make the common case fast</li>
    </ol>
    <p>storing stuff in registers is faster than going to main memory every time</p>
<pre>
<span class="function">move</span> <span class="constant">$t0</span>, <span class="constant">$t1</span>
<span class="comment"># is secretly</span>
<span class="function">add</span> <span class="constant">$t0</span>, <span class="constant">$0</span>, <span class="constant">$t1</span>
</pre>
    <aside>
      <p>see also <a href="../cs218">cs218</a> for mips</p>
    </aside>
    <ol start="4">
      <li>good design demands good compromise</li>
    </ol>
    <p>i) every instruction is 32 bits<br/>ii) minimal changes btwn instr formats</p>
    <h2>r-format instructions</h2>
    <p>used by the ALU</p>
<pre>
6      5     5     5     5     6
000000 00000 00000 00000 00000 000000
opcode rs    rt    rd    shamt funct
</pre>
    <p>risc has 32 registers so the registers each take up 5 bits</p>
    <p><coee>shamt</coee> is 'shift amount', used only for shl/shr, also 5 bits</p>
    <h2>i-format instructions</h2>
<pre>
6      5     5     16
000000 00000 00000 0000000000000000
opcode rs    rt    imm
</pre>
    <p><code>rt</code> is sometimes a source and sometimes a destination</p>
    <p>eg</p>
<pre>
<span class="function">lw</span> <span class="constant">$s0</span>, <span class="constant">4</span>(<span class="constant">$s2</span>)
</pre>
    <ul>
      <li><code class="constant">$s2</code> is <code>rs</code>
      <li><code class="constant">$s0</code> is <code>rt</code>
      <li><code class="constant">4</code> is the <i>offset</i> and goes in <code>imm</code>
    </ul>
    <h2>j-format instructions</h2>
<pre>
6      26
000000 00000000000000000000000000
opcode imm/addr
</pre>
    <h1>2026-02-09</h1>
    <h2>mips to hex</h2>
    <h3><code>
      <span class="function">add</span>
      <span class="constant">$t2</span><span class="fgmain">,</span>
      <span class="constant">$t0</span><span class="fgmain">,</span>
      <span class="constant">$t1</span>
    </code></h3>
    <p>
      the opcode is always 0 for r-format instructions. instead every r-format
      instruction has a function number. <code class="function">add</code>'s is 32
    </p>
    <p><code class="constant">$t0</code> has a register number of 8 etc</p>
    <p>so our instruction in binary is</p>
<pre>
000000 01000 01001 01010 00000 100000
0      8     9     10    0     32
</pre>
    <p>and in hex this is</p>
<pre>
0000 0001 0000 1001 0101 0000 0010 0000
0    1    0    9    5    0    2    0
</pre>
    <p> = <code>0x01095020</code></p>
    <h3><code>
      <span class="function">sw</span>
      <span class="constant">$s7</span><span class="fgmain">,</span>
      <span class="constant">4</span><span class="fgmain">(</span><span class="constant">$t0</span><span class="fgmain">)</span>
    </code></h3>
    <p><code class="function">sw</code>'s opcode is 43
<pre>
101011 01000 10111 0000000000000100
43     8     23    4
</pre>
<pre>
1010 1101 0001 0111 0000 0000 0000 0100
a    c    1    7    0    0    0    4
</pre>
    <p>= <code>0xac170004</code></p>
    <h3><code>
      <span class="function">j</span> <span class="constant">0x10000</span>
    </code></h3>
    <p>how do you fit a 32 bit address into 26 bits? you don't!</p>
    <p>
      offset address = (label address &minus; <code class="constant">$pc</code>) / 4
    </p>
    <p>
      tells you the number of instructions away it is! since instructions are
      <code class="type">int</code>s and therefore are 4 bytes long
    </p>
    <h1>2026-02-10</h1>
    <h2>logical instructions</h2>
    <p>useful for extracting and inserting certain groups of bits</p>
    <h3 class="smcp">and</h3>
    <p><code>and rd, rs, rt</code></p>
    <table>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>A &and; B</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
    </table>
    <h3 class="smcp">or</h3>
    <p><code>or rd, rs, rt</code></p>
    <table>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>A &or; B</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
    </table>
    <h3 class="smcp">nor</h3>
    <p><code>nor rd, rs, rt</code></p>
    <p>= 1s complement of <span class="smcp">or</span></p>
    <table>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>A &darr; B</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
      </tr>
    </table>
    <h3 class="smcp">not</h3>
    <p><code>nor rd, rs, $0</code></p>
    <p>for integers &not;<i>x</i> = -<i>x</i> &minus; 1</p>
    <table>
      <tr>
        <th>A</th>
        <th>&not;A</th>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
      </tr>
    </table>
    <h3>logical left shift</h3>
    <p><code>sll rd, rt, shamt</code></p>
    <p>eg <code>0b00001001</code> &ll; 2 = <code>0b00100100</code></p>
    <p>
      for unsigned integers this produces <i>rs</i> &times; 2<sup><i>shamt</i></sup>
    </p>
    <h3>logical right shift</h3>
    <p><code>srl rd, rt, shamt</code></p>
    <p>eg <code>0b10010001</code> &gg; 2 = <code>0b00100100</code></p>
    <p>for unsigned integers this produces <i>rs</i> / 2<sup><i>shamt</i></sup></p>
    <h2>32-bit constants</h2>
    <p>
      most constants are small. i-format instructions can only handle 16-bit immediates
    </p>
    <p>to put <code>0x12345678</code> into <code>$t0</code>, you write</p>
<pre>
<span class="function">li</span> <span class="constant">$t0</span>, <span class="constant">0x12345678</span>
<span class="comment"># is assembled into</span>
<span class="function">lui</span> <span class="constant">$at</span>, <span class="constant">0x1234</span>       <span class="comment"># Load Upper Immediate</span>
<span class="function">ori</span> <span class="constant">$t0</span>, <span class="constant">$at</span>, <span class="constant">0x5678</span>
</pre>
    <h1>2026-02-12</h1>
    <h2>addition</h2>
    <p><b>signed</b> numbers can be positive and negative and <b>unsigned</b> numbers can only be positive</p>
    <dl>
      <dt>overflow</dt>
      <dd>value outside the range that can fit, eg trying to fit 3&times;10<sup>9</sup> into an <code class="type">int</code></dd>
      <dt>underflow</dt>
      <dd>value less than the range, only for floating point numbers</dd>
    </dl>
    <p>if you try adding 2 negative numbers and get an extra bit, it doesn't count as an overflow unless the sign bit changes to positive. -3 + -3 = -6 doesn't overflow, but -6 + -8 = -14 = 2 does</p>
    <p>adding a positive and negative number will never overflow</p>
    <h2>multiplication</h2>
    <p>multipying two <i>n</i>-digit number gives an up-to-(2<i>n</i>)-digit number! whatever will we do!</p>
    <p>mips has 2 bonus registers <code>hi</code> and <code>lo</code> which together store a 64-bit number</p>
    <p>multiplying individual bits is like an <span class="smcp">and</span> gate</p>
    <h1>2026-02-17</h1>
    <h2>multiplication</h2>
    <h3>algorithm 1</h3>
    <p>here everything is eg 8 bits</p>
    <p>this is the boring "copy the multiplicand under every 1 in the multiplier"</p>
    <p>multiplicand is 8 bits (so it can hold the doubled values), multiplier and product are 4 bits</p>
    <ol>
      <li>fill the product with 0s</li>
      <li>for each bit of the multiplier:
        <ol>
          <li>if the lsb is 1, add the multiplicand to the product</li>
          <li>shift the multiplicand left 1 bit</li>
          <li>shift the multiplier right 1 bit</li>
        </ol>
      </li>
    </ol>
    <h3>optimized algorithm</h3>
    <p>here the product is eg 8 bits and the multiplicand and multiplier are both 4 bits</p>
    <ol>
      <li>place the multiplier in the right half of the product</li>
      <li>for each bit of the multiplier,
        <ol>
          <li>if the lsb is 1, add the multiplicand to the left half of the product</li>
          <li>shift the entire product right 1 bit</li>
        </ol>
      </li>
    </ol>
    <p>for 2 &times; 3 = 6:</p>
    <table>
      <tr><th>iter</th><th>product</th></tr>
      <tr><td>0</td><td>0000'0011</td></tr>
      <tr><td rowspan="2">1</td><td>0010'0011</td></tr>
      <tr><td>0001'0001</td></tr>
      <tr><td rowspan="2">2</td><td>0011'0001</td></tr>
      <tr><td>0001'1000</td></tr>
      <tr><td>3</td><td>0000'1100</td></tr>
      <tr><td>4</td><td>0000'0110</td></tr>
    </table>
    <h3>booth's algorithm (signed!)</h3>
    <p>product is 2n bits, multiplicand and multiplier are n bits, plus a "booth bit" (bb)</p>
    <ol>
      <li>place the multiplier in the right half of the product, set bb = 0</li>
      <li>for each bit of the multiplier:
        <ol>
          <li><span class="keyword">if</span> bb &gt; product lsb: product left half += multiplicand</li>
          <li><span class="keyword">else if</span> bb &lt; product lsb: product left half &minus;= multiplicand</li>
          <li><span class="keyword">else</span>: do nothing</li>
          <li>arithmetic right shift concatenated-product-and-bb by 1, sign extend</li>
        </ol>
      </li>
    </ol>
    <p>eg 7 &times; -9</p>
    <table>
      <tr><th>iter#</th><th>product</th><th>bb</th></tr>
      <tr><td>0</td><td>0000'0000'1111'0111</td><td>0</td></tr>
      <tr><td>1a</td><td>1111'1001'1111'0111</td><td>0</td></tr>
      <tr><td>1b</td><td>1111'1100'1111'1011</td><td>1</td></tr>
      <tr><td>2&ndash;3</td><td>1111'1111'0011'1110</td><td>1</td></tr>
      <tr><td>4a</td><td>0000'0110'0011'1110</td><td>1</td></tr>
      <tr><td>4b</td><td>0000'0011'0001'1111</td><td>0</td></tr>
      <tr><td>5a</td><td>1111'1100'0001'1111</td><td>0</td></tr>
      <tr><td>5b</td><td>1111'1110'0000'1111</td><td>1</td></tr>
      <tr><td>6&ndash;8</td><td>1111'1111'1100'0001</td><td>1</td></tr>
    </table>
    <h1>2026-02-19</h1>
    <h2>division</h2>
    <h3>algorithm 1</h3>
    <p>dividend is 8 bits, divisor and remainder fit in 4 bits but we make them be 8 instead, quotient is 4 bits</p>
    <ol>
      <li>place the dividend in the right half of remainder</li>
      <li>place the divisor in the left half of itself (shifted)</li>
      <li>for n+1 iterations:
        <ol>
          <li>remainder &minus;= divisor</li>
          <li>if remainder &lt; 0: restore (remainder += divisor), shift quotient left, lsb = 0; otherwise shift quotient left, lsb = 1</li>
          <li>shift divisor right 1 bit</li>
        </ol>
      </li>
    </ol>
    <p>for 7<sub>dividend</sub> ÷ 2<sub>divisor</sub></p>
    <table>
      <tr>
        <th>iter</th>
        <th>quotient</th>
        <th>divisor</th>
        <th>remainder</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0000</td>
        <td>0010'0000</td>
        <td>0000'0111</td>
      </tr>
      <tr>
        <td>1a</td>
        <td></td>
        <td></td>
        <td>1110'0111</td>
      </tr>
      <tr>
        <td>1b</td>
        <td>0000</td>
        <td></td>
        <td>0000'0111</td>
      </tr>
      <tr>
        <td>1c</td>
        <td></td>
        <td>0001'0000</td>
        <td></td>
      </tr>
      <tr>
        <td>2a</td>
        <td></td>
        <td></td>
        <td>1111'0111</td>
      </tr>
      <tr>
        <td>2b</td>
        <td>0000</td>
        <td></td>
        <td>0000'0111</td>
      </tr>
      <tr>
        <td>2c</td>
        <td></td>
        <td>0000'1000</td>
        <td></td>
      </tr>
      <tr>
        <td>3a</td>
        <td></td>
        <td></td>
        <td>1111'1111</td>
      </tr>
      <tr>
        <td>3b</td>
        <td>0000</td>
        <td></td>
        <td>0000'0111</td>
      </tr>
      <tr>
        <td>3c</td>
        <td></td>
        <td>0000'0100</td>
        <td></td>
      </tr>
      <tr>
        <td>4a</td>
        <td></td>
        <td></td>
        <td>0000'0011</td>
      </tr>
      <tr>
        <td>4b</td>
        <td>0001</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>4c</td>
        <td></td>
        <td>0000'0010</td>
        <td></td>
      </tr>
      <tr>
        <td>5a</td>
        <td></td>
        <td></td>
        <td>0000'0001</td>
      </tr>
      <tr>
        <td>5b</td>
        <td>0011</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>5c</td>
        <td></td>
        <td>0000'0001</td>
        <td></td>
      </tr>
      <tr>
        <td></td>
        <td>quot = 3</td>
        <td></td>
        <td>rem = 1</td>
      </tr>
    </table>
    <h3>optimized algorithm</h3>
    <p>remainder is 2n bits (left half starts at 0, right half = dividend), divisor and quotient are n bits. n iterations.</p>
    <ol>
      <li>for each iteration:
        <ol>
          <li>shift remainder left 1 bit</li>
          <li>subtract divisor from the left half of remainder</li>
          <li>if remainder &lt; 0: restore (undo step b), shift quotient left, quotient lsb = 0. otherwise: shift quotient left, quotient lsb = 1</li>
        </ol>
      </li>
    </ol>
    <p>eg 6 &divide; 3 = <code>0b0000'0110</code> &divide; <code>0b0011</code>, expected quotient 2 remainder 0:</p>
    <table>
      <tr><th>iter#</th><th>quotient</th><th>remainder</th></tr>
      <tr><td>0</td><td>0000</td><td>0000'0110</td></tr>
      <tr><td>1a</td><td>0000</td><td>0000'1100</td></tr>
      <tr><td>1b</td><td>0000</td><td>1101'1100</td></tr>
      <tr><td>1c</td><td>0000</td><td>0000'1100</td></tr>
      <tr><td>2a</td><td>0000</td><td>0001'1000</td></tr>
      <tr><td>2b</td><td>0000</td><td>1110'1000</td></tr>
      <tr><td>2c</td><td>0000</td><td>0001'1000</td></tr>
      <tr><td>3a</td><td>0000</td><td>0011'0000</td></tr>
      <tr><td>3b</td><td>0000</td><td>0000'0000</td></tr>
      <tr><td>3c</td><td>0001</td><td>0000'0000</td></tr>
      <tr><td>4a</td><td>0001</td><td>0000'0000</td></tr>
      <tr><td>4b</td><td>0001</td><td>1101'0000</td></tr>
      <tr><td>4c</td><td>0010</td><td>0000'0000</td></tr>
    </table>
    <h2>floats</h2>
    <dl>
      <dt>single precision</dt>
      <dd>32 bit (<code class="type">float</code>) → 6 decimal digit precision</dd>
      <dt>double precision</dt>
      <dd>64 bit (<code class="type">double</code>) → 16 decimal digit precision</dd>
    </dl>
    <p>single precision:</p>
    <pre>
1    8          23
0    000'0000'0 000'0000'0000'0000'0000'0000
sign exponent   mantissa</pre>
    <p><i>x</i> = (-1)<sup><i>s</i></sup> × (1. ⧺ mantissa) × 2<sup>exp − bias</sup></p>
    <p>the exponents 00000000 and 11111111 are reserved</p>
    <p>the bias for single precision is 127</p>
    <p>eg -0.75 = -1.1 × 2<sup>-1</sup> so exp = 126</p>
    <pre>
1 011'1111'0 100'0000'0000'0000'0000'0000 = 0x'bf40'0000</pre>
    <h3>fp addition/subtraction</h3>
    <ol>
      <li>align exponents: shift the significand of the smaller-exponent operand right until both exponents match</li>
      <li>add/subtract the significands</li>
      <li>normalize: shift result left/right and adjust exponent until it looks like 1.xxx</li>
      <li>check for exponent overflow/underflow</li>
      <li>round the mantissa to fit; if rounding changed the form, renormalize (go to step 3)</li>
    </ol>
    <p>eg 1.000 × 2<sup>-1</sup> + -1.110 × 2<sup>-2</sup>:</p>
    <ol>
      <li>shift: -1.110 × 2<sup>-2</sup> → -0.111 × 2<sup>-1</sup></li>
      <li>add: 1.000 + (-0.111) = 0.001 × 2<sup>-1</sup></li>
      <li>normalize: 0.001 × 2<sup>-1</sup> = 1.000 × 2<sup>-4</sup></li>
    </ol>
    <h3>fp multiplication</h3>
    <ol>
      <li>add the biased exponents, then subtract the bias once (since both already have it baked in: e<sub>1</sub> + e<sub>2</sub> − 127)</li>
      <li>multiply the significands (including the implicit leading 1) as unsigned integers</li>
      <li>normalize (same as addition step 3)</li>
      <li>check for exponent overflow/underflow</li>
      <li>round and renormalize if needed</li>
      <li>result sign = XOR of the two sign bits (0 if they were the same and 1 if they were different)</li>
    </ol>
  </body>
</html>
