<!doctype html>
<html>
  <head>
    <title>cs 219</title>
    <link rel="stylesheet" href="https://mi2ebi.github.io/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <h1 class="h0">cs 219</h1>
    <h1>2026-01-20</h1>
    <p>computers and brains are very similar!</p>
<pre>
        <span style="color: var(--green)">program</span>
           v
<span style="color: var(--red)">input</span> &gt; <span style="color: var(--green)">process</span> &gt; <span style="color: var(--magenta-cooler)">output</span>
           v
        <span style="color: var(--green)">storage</span>
</pre>
    <h2>parts of computers</h2>
    <ul>
      <li>input eg keyboard/mouse</li>
      <li>output eg screen</li>
      <li>memory</li>
      <li>
        processor
        <ul>
          <li>data path</li>
          <li>control unit</li>
        </ul>
      </li>
    </ul>
    <p>von neumann is slow tho so we can separate instruction memory vs data memory</p>
    <h2>types of computers</h2>
    <dl>
      <dt>personal computers</dt>
      <dd>general purpose, cost/perf tradeoff</dd>
      <dt>servers</dt>
      <dd>high capacity, performance, reliability</dd>
      <dt>supercomputers</dt>
      <dd>type of server, highest capabaility but super expensive etc</dd>
      <dt>embedded computers</dt>
      <dd>
        hidden as components of other systems, strict power/cost/perf requirements
      </dd>
      <dt>mobile devices</dt>
      <dd>rely more on batteries rather than eg being plugged in all the time</dd>
    </dl>
    <h2>"eight great ideas"</h2>
    <ol>
      <li>design for moore's law</li>
      <li>use abstraction to simplify design</li>
      <li>make the common case fast</li>
      <li>performance via parallelism</li>
      <li>performance via pipelining</li>
      <li>performance via prediction</li>
      <li>hierarchy of memories</li>
      <li>dependability via redundancy</li>
    </ol>
    <h1>2026-01-22</h1>
    <h2>below your program</h2>
    <ol>
      <li>application software</li>
      <li>system software eg compiler, os</li>
      <li><b>instruction set architecture</b></li>
      <li>hardware eg processor, memory, i/o</li>
    </ol>
    <h2>inside the cpu</h2>
    <dl>
      <dt>datapath</dt>
      <dd>perform ops on data</dd>
      <dt>control</dt>
      <dd>sequences datapath, memory, i/o</dd>
      <dt>cache</dt>
      <dd>small fast sram</dd>
    </dl>
    <dl>
      <dt>volatile/primary/main memory</dt>
      <dd>loses state when powered off</dd>
      <dt>nonvolatile/secondary memory</dt>
      <dd>eg hard drive, ssd, cdrom, usb stick</dd>
    </dl>
    <h2>networks</h2>
    <dl>
      <dt>local area network (lan)</dt>
      <dd>ethernet</dd>
      <dt>wide area network (wan)</dt>
      <dd>the internet</dd>
      <dt>wireless network</dt>
      <dd>eg wifi, bluetooth</dd>
    </dl>
    <h2>performance</h2>
    <dl>
      <dt>response time</dt>
      <dd>how long it takes to do something</dd>
      <dt>throughput</dt>
      <dd>total work done per unit of time</dd>
    </dl>
    <p>to get 'better performance':</p>
    <ul>
      <li>replace processor (rt down, t up)</li>
      <li>add more proessors (no changes to rt or t)</li>
    </ul>
    <p>perf &prop; 1/exectime</p>
    <h1>2026-01-27</h1>
    <p>
      a "2&#x202f;GHz" processor has a 1/(2&#x202f;GHz) = 0.5&#x202f;ns <small>=
      500&#x202f;ps</small> <b>clock cycle</b>
    </p>
    <p>ExecTime = ClockCycles &times; CycleTime = ClockCycles / ClockRate</p>
    <blockquote>
      [the math] is trying to touch your brain a little bit.
      squeeze it, but not crush it<br />
      &ndash; <cite>prof chidella</cite>
    </blockquote>
    <p>CPI = clock cycles per instruction</p>
    <p>in mips, memory instructions take the most clock cycles</p>
    <p>
      mips stands for <del>million instructions per second</del> <ins>microprocessor without interlocked pipeline stages</ins>
    </p>
    <dl>
      <dt>standard equation for ET</dt>
      <dd>
        ET<br />
        = CC &times; CT<br />
        = IC &times; CPI &times; CT<br />
        = IC &times; CPI / CR
      </dd>
    </dl>
    <h1>2026-01-29</h1>
    <h2>bin and hex</h2>
    <p>to convert positive integers to binary: keep dividing by 2 until you get a result less than 2, and prepend each remainder + that final result</p>
<pre>
<span class="keyword">fn</span> <span class="function">udec2bin</span>(<span class="variable">x</span>: <span class="type">u32</span>) -&gt; <span class="type">String</span> {
  <span class="keyword">if</span> <span class="variable">x</span> == <span class="constant">0</span> <span class="rainbow1">{</span>
    <span class="keyword">return</span> <span class="string">"0"</span>.<span class="function">to_string</span><span class="rainbow2">()</span>;
  <span class="rainbow1">}</span>
  <span class="keyword">let mut</span> <span class="variable">bin</span> = <span class="type">String</span>::<span class="function">new</span><span class="rainbow1">()</span>;
  <span class="keyword">let mut</span> <span class="variable">x</span> = <span class="variable">x</span>;
  <span class="keyword">while</span> <span class="variable">x</span> &gt; <span class="constant">0</span> <span class="rainbow1">{</span>
    <span class="variable">bin</span> = <span class="builtin">format!</span><span class="rainbow2">(</span><span class="string">"<span class="rainbow3">{}{</span><span class="variable">bin</span><span class="rainbow3">}</span>"</span>, <span class="variable">x</span> % <span class="constant">2</span><span class="rainbow2">)</span>;
    <span class="variable">x</span> /= <span class="constant">2</span>;
  <span class="rainbow1">}</span>
  <span class="variable">bin</span>
}
</pre>
    <p>for negative integers use 2s complement</p>
    <ol>
      <li>ignore the sign and convert it as if it were positive</li>
      <li>1s complement (flip all the bits)</li>
      <li>add 1</li>
    </ol>
    <p>the range of a signed <i>n</i>-bit integer type is -2<sup><i>n</i>&minus;1</sup> to 2<sup><i>n</i>&minus;1</sup>&nbsp;&minus;&nbsp;1</p>
    <p>eg <code class="type">i32</code> can store numbers from -2,147,483,648 to 2,147,483,647</p>
    <h2>"4 design principles"</h2>
    <ol>
      <li>simplicity favors regularity</li>
    </ol>
    <p>risc has 1 implementation for eg <code class="function">add</code> where cisc can add <a href="https://www.felixcloutier.com/x86/add">tons of types of thing</a> with the same instruction. in risc there's just</p>
<pre>
<span class="comment"># rdst = rsrc + rsr2</span>
<span class="function">add</span> <span class="variable">rdst</span>, <span class="variable">rsrc</span>, <span class="variable">rsr2</span>
</pre>
    <ol start="2">
      <li>smaller is faster</li>
    </ol>
    <p>risc uses only 32bit registers, cisc uses whatever the native size is</p>
    <ol start="3">
      <li>make the common case fast</li>
      <li>good design demands good compromise</li>
    </ol>
  </body>
</html>
